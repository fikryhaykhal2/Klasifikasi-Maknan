# -*- coding: utf-8 -*-
"""opp.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ktIOKDjQrqRqLaTtAk5C2WiW7Ch9qavK
"""

!pip install streamlit
!pip install tensorflow

import streamlit as st
import tensorflow as tf
from tensorflow.keras.models import load_model
from tensorflow.keras.preprocessing import image
import numpy as np
from PIL import Image
import os

# --- 1. Definisi Konstanta dan Pemetaan Kelas ---

# Nama file model yang telah diunduh dari Drive
# PASTIKAN FILE INI ADA DI DIREKTORI YANG SAMA DENGAN app.py
MODEL_PATH = 'model_trained_5class_resnet101-v1.hdf5'

# Ukuran gambar yang diharapkan oleh model Anda
IMG_WIDTH, IMG_HEIGHT = 128, 128

# Pemetaan kelas (sesuai dengan output train_generator.class_indices)
# Urutkan secara alfabetis agar konsisten, karena generator biasanya mengurutkan.
# Periksa kembali urutan di notebook Anda jika tidak yakin.
CLASS_NAMES = ['croissant', 'hamburger', 'pancakes', 'takoyaki', 'waffles']

# --- 2. Memuat Model (dengan Caching) ---

# Menggunakan st.cache_resource agar model hanya dimuat sekali
@st.cache_resource
def load_and_compile_model(model_path):
    # Menggunakan compile=False karena model sudah dilatih
    model = load_model(model_path, compile=False)
    # Anda juga dapat mengompilasinya dengan optimizer dan loss yang sama
    # model.compile(optimizer=tf.keras.optimizers.SGD(learning_rate=0.0001, momentum=0.9),
    #               loss='categorical_crossentropy', metrics=['accuracy'])
    return model

# --- 3. Fungsi Preprocessing dan Prediksi ---

def model_predict(img_path, model):
    """Memproses gambar dan melakukan prediksi."""

    # Memuat dan mengubah ukuran gambar
    img = image.load_img(img_path, target_size=(IMG_WIDTH, IMG_HEIGHT))

    # Mengubah gambar menjadi array numpy
    img_array = image.img_to_array(img)

    # Menambahkan dimensi batch (1, 128, 128, 3)
    img_array = np.expand_dims(img_array, axis=0)

    # Normalisasi (seperti di notebook Anda)
    img_array /= 255.0

    # Melakukan prediksi
    pred = model.predict(img_array, verbose=0)

    # Mendapatkan indeks dengan probabilitas tertinggi
    index = np.argmax(pred)

    # Mendapatkan nilai prediksi dan kepercayaan
    pred_value = CLASS_NAMES[index]
    confidence = pred[0][index] * 100

    return pred_value, confidence

# --- 4. Aplikasi Streamlit Utama ---

def main():
    st.set_page_config(page_title="Food Image Classifier (ResNet50)", layout="centered")

    st.title("ðŸ” Food Image Classifier Prototype")
    st.markdown("Model: **ResNet50 Fine-tuned** (5 Kelas: Croissant, Hamburger, Takoyaki, Pancakes, Waffles)")

    # Pemuatan Model
    try:
        model = load_and_compile_model(MODEL_PATH)
        st.success("Model berhasil dimuat! Silakan unggah gambar.")
    except Exception as e:
        st.error(f"Gagal memuat model. Pastikan file '{MODEL_PATH}' ada. Error: {e}")
        return

    st.markdown("---")

    # Widget Unggah File
    uploaded_file = st.file_uploader("Unggah gambar makanan (JPG, JPEG, PNG)...", type=["jpg", "jpeg", "png"])

    if uploaded_file is not None:
        # Menampilkan gambar yang diunggah
        image_to_predict = Image.open(uploaded_file)
        st.image(image_to_predict, caption='Gambar yang Diunggah', use_column_width=True)
        st.markdown("---")

        # Membuat file sementara untuk prediksi
        with open(os.path.join("temp_img.jpg"), "wb") as f:
            f.write(uploaded_file.getbuffer())

        # Melakukan Prediksi
        with st.spinner('Menganalisis gambar...'):
            predicted_class, confidence = model_predict("temp_img.jpg", model)

        # Menampilkan Hasil
        st.subheader("âœ… Hasil Prediksi")

        # Menggunakan emoji untuk visualisasi
        emoji = "ðŸ†" if confidence > 80 else "ðŸ¤”"

        st.metric(
            label="Kelas Makanan",
            value=f"{predicted_class.upper()} {emoji}",
            delta=f"{confidence:.2f}% Confidence"
        )

        st.balloons()

# Menjalankan fungsi utama
if __name__ == '__main__':
    main()